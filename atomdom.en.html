<!DOCTYPE html><html class="formal-specification anolis" lang=en><head>
<title>Atom DOM</title>
<link href=http://suika.suikawiki.org/www/style/html/spec rel=stylesheet>
<link href=#license rel=license>
</head>
<body class=has-abstract>

<header>

<hgroup>
  <h1 class="no-toc no-num">Atom DOM</h1>
  <h2 class="no-toc no-num">Manakai Project Living Standard 8 April 2013</h2>
</hgroup>

<dl class=versions-uri>
<dt>Latest Version</dt>
  <dd><code class=URI>&lt;<a href=http://suika.fam.cx/www/markup/xml/atomdom>http://suika.fam.cx/www/markup/xml/atomdom</a>&gt;</code></dd>
<dt>Version History</dt>
  <dd><code class=URI>&lt;<a href=http://suika.fam.cx/gate/git/wi/markup/xmlexts.git/history/HEAD:/atomdom-source.en.html>http://suika.fam.cx/gate/git/wi/markup/xmlexts.git/history/HEAD:/atomdom-source.en.html</a>&gt;</code></dd>
<dt id=author>Author</dt>
  <dd><a href=http://suika.fam.cx/~wakaba/who? lang=ja rel=author>Wakaba</a>
  <code class=mail>&lt;<a href=mailto:wakaba@suikawiki.org rel=author>wakaba@suikawiki.org</a>&gt;</code></dd>
</dl>

<p class=copyright id=license lang=en><a href=http://creativecommons.org/publicdomain/zero/1.0/ rel=license><img alt=CC0 src=http://i.creativecommons.org/p/zero/1.0/80x15.png></a> To the
extent possible under law, the editor has waived all copyright and
related or neighboring rights to this work.  In addition, as of
8 April 2013, the editor has made this specification available under the <a href=http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0>Open
Web Foundation Agreement Version 1.0</a>.

</p></header>

<section id=status>
<h2 class="no-toc no-num" id=status-of-this-document>Status of This Document</h2>

<p class=section-info><em>This section describes the status of this
document at the time of its publication.  Other documents might
supersede this document.</em></p>

<p>This document is a technical specification produced as part of the
<a href=https://github.com/manakai>manakai</a> project.  It might be
updated, replaced, or obsoleted by other documents at any time.

</p><p>The scope of this specification is explicitly limited within the
manakai project.  It does not intended to be supported by multiple
parties, although nothing prevents it from implemented by other DOM
implementations.

</p><p>Comments on this document are welcome and may be sent to the <a href=#author>author</a>.</p>

<p>Translations of thie document might be available.  The English
version of the document is the only normative version.</p>
</section>

<section>
<h2 class="no-toc no-num" id=table-of-contents>Table of contents</h2>

<!--begin-toc-->
<ol class=toc>
 <li><a href=#introduction><span class=secno>1 </span>Introduction</a>
  <ol>
   <li><a href=#history><span class=secno>1.1 </span>History</a></li></ol></li>
 <li><a href=#definitions><span class=secno>2 </span>Definitions</a>
  <ol>
   <li><a href=#conformance><span class=secno>2.1 </span>Conformance</a></li>
   <li><a href=#terms><span class=secno>2.2 </span>Terms</a></li>
   <li><a href=#dom-operations><span class=secno>2.3 </span>DOM operations</a></li></ol></li>
 <li><a href=#document-constructors><span class=secno>3 </span>Document constructors</a></li>
 <li><a href=#dom-interfaces-for-atom-elements><span class=secno>4 </span>DOM interfaces for Atom elements</a>
  <ol>
   <li><a href=#the-atomelement-interface><span class=secno>4.1 </span>The <code>AtomElement</code> interface</a></li>
   <li><a href=#the-atomtextconstruct-interface><span class=secno>4.2 </span>The <code>AtomTextConstruct</code> interface</a></li>
   <li><a href=#the-atompersonconstruct-interface><span class=secno>4.3 </span>The <code>AtomPersonConstruct</code> interface</a></li>
   <li><a href=#the-atomdateconstruct-interface><span class=secno>4.4 </span>The <code>AtomDateConstruct</code> interface</a></li>
   <li><a href=#the-atomfeedelement-interface><span class=secno>4.5 </span>The <code>AtomFeedElement</code> interface</a></li></ol></li>
 <li><a href=#changes-from-earlier-versions><span class=secno>5 </span>Changes from earlier versions</a></li>
 <li><a class=no-num href=#references>References</a></li></ol>
<!--end-toc-->
</section>

<section>
<h2 id=introduction><span class=secno>1 </span>Introduction</h2>

<p>The <dfn id=atom-dom>Atom DOM</dfn> is a language and platform independent
programming language interface to Atom documents built on top of
language-neutral DOM APIs <cite class="bibref normative">[<a href=#ref-DOM>DOM</a>]</cite>.  It defines a number of interfaces
that provide convenience methods and attributes to process Atom
documents <cite class="bibref normative">[<a href=#ref-ATOM>ATOM</a>]</cite>.

</p><section>
<h3 id=history><span class=secno>1.1 </span>History</h3>

<p class=ed>XXX

</p></section>

</section>

<section>
<h2 id=definitions><span class=secno>2 </span>Definitions</h2>

<section>
<h3 id=conformance><span class=secno>2.1 </span>Conformance</h3>

<p>The keywords "<em class=rfc2119>MUST</em>", "<em class=rfc2119>MUST
NOT</em>", "<em class=rfc2119>SHOULD</em>", and "<em class=rfc2119>MAY</em>" in the normative parts of this document are to
be interpreted as described in <a href=http://tools.ietf.org/html/rfc2119>RFC 2119</a> <cite class="bibref normative">[<a href=#ref-RFC2119>RFC2119</a>]</cite>.

</p><p>Requirements phrased in the imperative as part of algorithms (such
as "strip any leading space characters" or "return false and abort
these steps") are to be interpreted with the meaning of the key word
("<em class=rfc2119>MUST</em>", "<em class=rfc2119>MAY</em>", etc)
used in introducing the algorithm.

</p><p>Conformance requirements phrased as algorithms or specific steps
<em class=rfc2119>MAY</em> be implemented in any manner, so long as
the end result is equivalent. (In particular, the algorithms defined
in this specification are intended to be easy to follow, and not
intended to be performant.)

</p><p>User agents <em class=rfc2119>MAY</em> impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.
</p></section>

<section>
<h3 id=terms><span class=secno>2.2 </span>Terms</h3>

<p>The terms <dfn id=context-object>context object</dfn>, <dfn id=concept-tree-child title=concept-tree-child>child</dfn>, <dfn id=concept-tree-order title=concept-tree-order>tree order</dfn>, <dfn id=concept-node-append title=concept-node-append>append</dfn>, <dfn id=concept-node-document title=concept-node-document>node document</dfn>, <dfn id=dom-node-textcontent title=dom-Node-textContent><code>textContent</code></dfn>,
<dfn id=document><code>Document</code></dfn>, <dfn id=concept-document title=concept-document>document</dfn>, <dfn id=concept-document-content-type title=concept-document-content-type>content type</dfn>,
<dfn id=element><code>Element</code></dfn>, <dfn id=concept-element title=concept-element>element</dfn>, <dfn id=concept-element-local-name title=concept-element-local-name>local name</dfn>, <dfn id=concept-element-namespace title=concept-element-namespace>namespace</dfn>, <dfn id=concept-element-interface title=concept-element-interface>element interface</dfn>, <dfn id=concept-attribute title=concept-attribute>attribute</dfn>, <dfn id=content-attribute>content attribute</dfn>,
<dfn id=concept-attribute-value title=concept-attribute-value>value</dfn>, <dfn id=concept-element-attributes-set title=concept-element-attributes-set>set an attribute</dfn>,
<dfn id=reflect>reflect</dfn>, <dfn id=text><code>Text</code></dfn>, <dfn id=concept-cd-data title=concept-cd-data>data</dfn>,
<dfn id=htmlcollection><code>HTMLCollection</code></dfn>, <dfn id=concept-collection-live title=concept-collection-live>live</dfn>, <dfn id=concept-collection-static title=concept-collection-static>static</dfn>, <dfn id=xml-namespace>XML
namespace</dfn>, <dfn id=html-namespace>HTML namespace</dfn>,
<dfn id=domimplementation><code>DOMImplementation</code></dfn>, and <dfn id=dom-domimplementation-createdocument title=dom-DOMImplementation-createDocument><code>createDocument</code></dfn>
are defined by the DOM Standard <cite class="bibref normative">[<a href=#ref-DOM>DOM</a>]</cite>.

</p><p>The terms <dfn id=resolve-a-url>resolve a URL</dfn>, <dfn id=parse-a-global-date-and-time-string>parse a global date and
time string</dfn>, and <dfn id=valid-normalized-forced-utc-global-date-and-time-string>valid normalized forced-UTC global date
and time string</dfn> are defined by the HTML Standard <cite class="bibref normative">[<a href=#ref-HTML>HTML</a>]</cite>.

</p><p>The <dfn id=atom-namespace>Atom namespace</dfn> is
<code>http://www.w3.org/2005/Atom</code>.

</p><p>The <dfn id=svgelement><code>SVGElement</code></dfn> interface is defined in the
SVG specification <cite class="bibref normative">[<a href=#ref-SVG>SVG</a>]</cite>.

</p><p>The <dfn id=manakai-create-child-element><a href=http://suika.suikawiki.org/~wakaba/wiki/sw/n/manakai%20DOM%20Extensions#anchor-97><code>manakai-create-child-element</code></a></dfn>
<span>configuration parameter</span> is defined in the manakai DOM
Extensions specification <cite class="bibref normative">[<a href=#ref-MANAKAI>MANAKAI</a>]</cite>.

</p><p>The IDL fragments in this specification <em class=rfc2119>MUST</em>
be interpreted as described in the WebIDL specification <cite class="bibref normative">[<a href=#ref-WEBIDL>WEBIDL</a>]</cite>.

</p></section>

<section>
<h3 id=dom-operations><span class=secno>2.3 </span>DOM operations</h3>

<p>To <dfn id=set-the-xml:lang-attribute>set the <code>xml:lang</code> attribute</dfn> of an <a href=#concept-element title=concept-element>element</a> <var title="">element</var> to value
<var>value</var>, the <a href=#concept-element-attributes-set title=concept-element-attributes-set>set
an attribute</a> steps <em class=rfc2119>MUST</em> be invoked using
<var title="">element</var>, <var title="">value</var>, <var title="">local
name</var> <code>lang</code>, <var title="">prefix</var>
<code>xml</code>, and <var title="">namespace</var> the <a href=#xml-namespace>XML
namespace</a>.

</p><p>To <dfn id=concept-append-atom-element title=concept-append-atom-element>append an Atom
element</dfn> <var title="">local name</var> with <var title="">text
content</var> to <var title="">parent</var>, the following steps <em class=rfc2119>MUST</em> be run:

</p><ol class=algorithm>

<li>Let <var title="">element</var> be an <a href=#concept-element title=concept-element>element</a> whose <a href=#concept-element-local-name title=concept-element-local-name>local name</a> is <var title="">local
name</var> and <a href=#concept-element-namespace title=concept-element-namespace>namespace</a>
is the <a href=#atom-namespace>Atom namespace</a>.

</li><li>If <var title="">text content</var> is not the empty string, <a href=#concept-node-append title=concept-node-append>append</a> a <a href=#text><code>Text</code></a> node whose
<a href=#concept-cd-data title=concept-cd-data>data</a> is <var title="">text
content</var>.

</li><li><a href=#concept-node-append title=concept-node-append>Append</a> <var title="">element</var> to <var title="">parent</var>.

</li></ol>

<p>To <dfn id=obtain-the-child-element>obtain the child element</dfn> of <var title="">element</var>
with <var title="">local name</var> and optionally <var title="">namespace</var>, the following steps <em class=rfc2119>MUST</em>
be run:

</p><ol class=algorithm>

<li>Let <var title="">namespace</var> be the <a href=#atom-namespace>Atom namespace</a>
if it is not explicitly given.

</li><li>If <var title="">element</var> has a <a href=#concept-tree-child title=concept-tree-child>child</a> <a href=#concept-element title=concept-element>element</a> whose <a href=#concept-element-local-name title=concept-element-local-name>local name</a> is <var title="">local
name</var> and <a href=#concept-element-namespace><var title=concept-element-namespace>namespace</var></a>,
return the first such <a href=#concept-element title=concept-element>element</a> in
<a href=#concept-tree-order title=concept-tree-order>tree order</a> and abort these
steps.

</li><li>Otherwise, if the <a href=#manakai-create-child-element><code>manakai-create-child-element</code></a>
<span>configuration parameter</span> of the <a href=#concept-node-document title=concept-node-document>node document</a> of <var title="">element</var> is set to true:

  <ol class=algorithm>

  <li>Let <var title="">child</var> be an <a href=#concept-element title=concept-element>element</a> whose <span title=concept-local-name>local name</span> is <var title="">local
  name</var> and <span title=concept-namespace>namespace</span> is
  <var title="">namespace</var>.

  </li><li><span title=concept-tree-append>Append</span> <var title="">child</var> to <var title="">element</var>.

  </li><li>Return <var title="">child</var> and abort these steps.

  </li></ol>

</li><li>Otherwise, return <code>null</code>.

</li></ol>

<p>The <dfn id=child-element-list>child element list</dfn> of type <var title="">local
name</var> for <a href=#concept-element title=concept-element>element</a> <var title="">element</var> is an <a href=#htmlcollection><code>HTMLCollection</code></a> rooted at the
<var title="">element</var>, whose filter matches only <a href=#concept-tree-child title=concept-tree-child>child</a> <a href=#concept-element title=concept-element>elements</a> of <var title="">element</var> with
<a href=#concept-element-local-name title=concept-element-local-name>local name</a> <var title="">local name</var> and <a href=#concept-element-namespace title=concept-element-namespace>namespace</a> the <a href=#atom-namespace>Atom
namespace</a>.

  </p><div class="note memo">

    <p>As specified in the DOM Standard, <a href=#htmlcollection><code>HTMLCollection</code></a>
    objects are <a href=#concept-collection-live title=concept-collection-live>live</a> by
    default.  Attributes returning <a href=#htmlcollection><code>HTMLCollection</code></a> always
    return the same object.

  </p></div>

<hr>

<p>If an attribute <dfn id=reflect-the-string-value-of-a-child-element title="reflect the string value of a child
element">reflects the string value of the child element <var title="">local name</var></dfn>, optionally with <var title="">namespace</var>, on getting, the attribute <em class=rfc2119>MUST</em> run the following steps:

</p><ol class=algorithm>

<li>Let <var title="">namespace</var> be the <a href=#atom-namespace>Atom namespace</a>
if it is not explicitly given.

</li><li>If <var title="">element</var> has a <a href=#concept-tree-child title=concept-tree-child>child</a> <a href=#concept-element title=concept-element>element</a> whose <a href=#concept-element-local-name title=concept-element-local-name>local name</a> is <var title="">local
name</var> and <a href=#concept-element-namespace><var title=concept-element-namespace>namespace</var></a>,
return the <a href=#dom-node-textcontent><code title=dom-Node-textContent>textContent</code></a>
attribute value of the first such <a href=#concept-element title=concept-element>element</a> in <a href=#concept-tree-order title=concept-tree-order>tree order</a>.

</li><li>Otherwise, return the empty string.

</li></ol>

<p>If an attribute <dfn id=reflect-the-url-value-of-a-child-element title="reflect the URL value of a child
element">reflects the URL value of the child element <var title="">local
name</var></dfn>, optionally with <var title="">namespace</var>, on
getting, the attribute <em class=rfc2119>MUST</em> run the following
steps:

</p><ol class=algorithm>

<li>Let <var title="">namespace</var> be the <a href=#atom-namespace>Atom namespace</a>
if it is not explicitly given.

</li><li>If <var title="">element</var> has a <a href=#concept-tree-child title=concept-tree-child>child</a> <a href=#concept-element title=concept-element>element</a> whose <a href=#concept-element-local-name title=concept-element-local-name>local name</a> is <var title="">local
name</var> and <a href=#concept-element-namespace><var title=concept-element-namespace>namespace</var></a>:

  <ol class=algorithm>

  <li>Let <var title="">child</var> be the first such <a href=#concept-element title=concept-element>element</a> in <a href=#concept-tree-order title=concept-tree-order>tree order</a>.

  </li><li><a href=#resolve-a-url title="resolve a URL">Resolve</a> the <a href=#dom-node-textcontent><code title=dom-Node-textContent>textContent</code></a> attribute value of
  <var title="">child</var>, relative to <var title="">child</var>.  If it
  results in an error, return the empty string.  Otherwise, return the
  result.

  </li></ol>

</li><li>Otherwise, return the empty string.

</li></ol>

<p>If an attribute reflects the <a href=#reflect-the-string-value-of-a-child-element title="reflect the string value
of a child element">string</a> or <a href=#reflect-the-url-value-of-a-child-element title="reflect the URL
value of a child element">URL</a> value of the child element, on
setting, the attribute <em class=rfc2119>MUST</em> run the following
steps:

</p><ol class=algorithm>

<li>Let <var title="">namespace</var> be the <a href=#atom-namespace>Atom namespace</a>
if it is not explicitly given.

</li><li>If <var title="">element</var> has a <a href=#concept-tree-child title=concept-tree-child>child</a> <a href=#concept-element title=concept-element>element</a> whose <a href=#concept-element-local-name title=concept-element-local-name>local name</a> is <var title="">local
name</var> and <a href=#concept-element-namespace><var title=concept-element-namespace>namespace</var></a>,
act as if the <a href=#dom-node-textcontent><code title=dom-Node-textContent>textContent</code></a>
attribute of the first such <a href=#concept-element title=concept-element>element</a>
in <a href=#concept-tree-order title=concept-tree-order>tree order</a> is set to the
given value and abort these steps.

</li><li>Let <var title="">child</var> be an <a href=#concept-element title=concept-element>element</a> whose <span title=concept-local-name>local name</span> is <var title="">local
name</var> and <span title=concept-namespace>namespace</span> is <var title="">namespace</var>.

</li><li>If the given value is not the empty string, <a href=#concept-node-append title=concept-node-append>append</a> a <a href=#text><code>Text</code></a> whose
<a href=#concept-cd-data title=concept-cd-data>data</a> is the given value to <var title="">child</var>.

</li><li><span title=concept-tree-append>Append</span> <var title="">child</var> to the <a href=#context-object>context object</a>.

</li></ol>

</section>

</section>

<section>
<h2 id=document-constructors><span class=secno>3 </span>Document constructors</h2>

<p>Document constructor methods are added to the
<a href=#domimplementation><code>DOMImplementation</code></a> object as follows:

</p><pre class=idl id=AtomImplementation><code>partial interface <a href=#domimplementation>DOMImplementation</a> {
  <a href=#document>Document</a> <a href=#dom-domimplementation-createatomfeeddocument title=dom-DOMImplementation-createAtomFeedDocument>createAtomFeedDocument</a>(<span>DOMString</span> id, [TreatNullAs=EmptyString] <span>DOMString</span> title, [TreatNullAs=EmptyString] <span>DOMString</span> lang);
  <a href=#document>Document</a> <a href=#dom-domimplementation-createatomentrydocument title=dom-DOMImplementation-createAtomEntryDocument>createAtomEntryDocument</a>(<span>DOMString</span> id, [TreatNullAs=EmptyString] <span>DOMString</span> title, [TreatNullAs=EmptyString] <span>DOMString</span> lang);
};</code></pre>

<p>The <dfn id=dom-domimplementation-createatomfeeddocument title=dom-DOMImplementation-createAtomFeedDocument><code>createAtomFeedDocument(<var title="">id</var>, <var title="">title</var>, <var title="">lang</var>)</code></dfn> method <em class=rfc2119>MUST</em> run
the following steps:

</p><ol class=algorithm>

<li>Let <var title="">document</var> be a <a href=#concept-document title=concept-document>document</a> that would be returned by the
invocation of the <a href=#dom-domimplementation-createdocument><code title=dom-DOMImplementation-createDocument>createDocument</code></a>
method on the <a href=#context-object>context object</a>.

</li><li>Set the <a href=#concept-document-content-type title=concept-document-content-type>content
type</a> of <var title="">document</var> to
<code>application/atom+xml</code>.

</li><li>Let <var title="">feed</var> be a <code>feed</code> <a class=concept-element href=#element>element</a> in the <a href=#atom-namespace>Atom
namespace</a>.

</li><li><a href=#concept-node-append title=concept-node-append>Append</a> <var title="">feed</var> to <var title="">document</var>.

</li><li><a href=#set-the-xml:lang-attribute>Set the <code>xml:lang</code> attribute</a> of <var title="">feed</var> to <var title="">lang</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>id</code> element</a> whose <var title="">text content</var> is
<var title="">id</var> to <var title="">feed</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>title</code> element</a> whose <var title="">text content</var>
is <var title="">title</var> to <var title="">feed</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>updated</code> element</a> whose <var title="">text
content</var> is <a href=#valid-normalized-forced-utc-global-date-and-time-string>valid normalized forced-UTC global date and
time string</a> of the current time to <var title="">feed</var>.

</li><li>Return <var title="">document</var>.

</li></ol>

<p>The <dfn id=dom-domimplementation-createatomentrydocument title=dom-DOMImplementation-createAtomEntryDocument><code>createAtomEntryDocument(<var title="">id</var>, <var title="">title</var>, <var title="">lang</var>)</code></dfn> method <em class=rfc2119>MUST</em> run
the following steps:

</p><ol class=algorithm>

<li>Let <var title="">document</var> be a <a href=#concept-document title=concept-document>document</a> that would be returned by the
invocation of the <a href=#dom-domimplementation-createdocument><code title=dom-DOMImplementation-createDocument>createDocument</code></a>
method on the <a href=#context-object>context object</a>.

</li><li>Set the <a href=#concept-document-content-type title=concept-document-content-type>content
type</a> of <var title="">document</var> to
<code>application/atom+xml</code>.

</li><li>Let <var title="">entry</var> be a <code>entry</code> <a class=concept-element href=#element>element</a> in the <a href=#atom-namespace>Atom
namespace</a>.

</li><li><a href=#concept-node-append title=concept-node-append>Append</a> <var title="">entry</var> to <var title="">document</var>.

</li><li><a href=#set-the-xml:lang-attribute>Set the <code>xml:lang</code> attribute</a> of <var title="">entry</var> to <var title="">lang</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>id</code> element</a> whose <var title="">text content</var> is
<var title="">id</var> to <var title="">entry</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>title</code> element</a> whose <var title="">text content</var>
is <var title="">title</var> to <var title="">entry</var>.

</li><li><a href=#concept-append-atom-element title=concept-append-atom-element>Append an Atom
<code>updated</code> element</a> whose <var title="">text
content</var> is <a href=#valid-normalized-forced-utc-global-date-and-time-string>valid normalized forced-UTC global date and
time string</a> of the current time to <var title="">entry</var>.

</li><li>Return <var title="">document</var>.

</li></ol>

</section>

<section>
<h2 id=dom-interfaces-for-atom-elements><span class=secno>4 </span>DOM interfaces for Atom elements</h2>

<section>
<h3 id=the-atomelement-interface><span class=secno>4.1 </span>The <a href=#atomelement><code>AtomElement</code></a> interface</h3>

<p>The <a href=#concept-element-interface title=concept-element-interface>element interface</a>
for <a href=#concept-element title=concept-element>elements</a> in the <a href=#atom-namespace>Atom
namespace</a> is <a href=#atomelement><code>AtomElement</code></a>, unless stated otherwise.

</p><pre class=idl><code>interface <dfn id=atomelement>AtomElement</dfn> : <a href=#element>Element</a> {
  attribute DOMString <a href=#concept-atomelement-xmlbase title=concept-AtomElement-xmlbase>xmlbase</a>;
  attribute DOMString <a href=#concept-atomelement-xmllang title=concept-AtomElement-xmllang>xmllang</a>;
};</code></pre>

<p>The <dfn id=concept-atomelement-xmlbase title=concept-AtomElement-xmlbase><code>xmlbase</code></dfn> attribute
of the <a href=#atomelement><code>AtomElement</code></a> interface <em class=rfc2119>MUST</em>
behave in the same way as the <a href=https://svgwg.org/svg2-draft/single-page.html#types-__svg__SVGElement__xmlbase><code>xmlbase</code></a>
attribute of the <a href=#svgelement><code>SVGElement</code></a> interface.

</p><p>The <dfn id=concept-atomelement-xmllang title=concept-AtomElement-xmllang><code>xmllang</code></dfn> attribute
of the <a href=#atomelement><code>AtomElement</code></a> interface <em class=rfc2119>MUST</em>
behave in the same way as the <a href=https://svgwg.org/svg2-draft/single-page.html#types-__svg__SVGElement__xmllang><code>xmllang</code></a>
attribute of the <a href=#svgelement><code>SVGElement</code></a> interface.
</p></section>

<section>
<h3 id=the-atomtextconstruct-interface><span class=secno>4.2 </span>The <a href=#atomtextconstruct><code>AtomTextConstruct</code></a> interface</h3>

<pre class=idl><code>[NoInterfaceObject]
interface <dfn id=atomtextconstruct>AtomTextConstruct</dfn> : <a href=#atomelement>AtomElement</a> {
  attribute <span>DOMString</span> <a href=#concept-atomtextconstruct-type title=concept-AtomTextConstruct-type>type</a>;
  readonly attribute <a href=#element>Element</a>? <a href=#concept-atomtextconstructor-container title=concept-AtomTextConstructor-container>container</a>;
};</code></pre>

<p>The <dfn id=concept-atomtextconstruct-type title=concept-AtomTextConstruct-type><code>type</code></dfn> attribute
of the <a href=#atomtextconstruct><code>AtomTextConstruct</code></a> <em class=rfc2119>MUST</em>
<a href=#reflect>reflect</a> the <a href=#content-attribute>content attribute</a> of the same
name.  The default value for the attribute is <a href=#text><code>text</code></a>.

</p><p>The <dfn id=concept-atomtextconstructor-container title=concept-AtomTextConstructor-container><code>container</code></dfn>
attribute <em class=rfc2119>MUST</em> run the following steps:

</p><ol class=algorithm>

<li>If the <a href=#concept-attribute-value title=concept-attribute-value>value</a> of the
<code>type</code> <a href=#concept-attribute title=concept-attribute>content
attribute</a> of the <a href=#context-object>context object</a>, if any, is
<code>xhtml</code>, return <a href=#obtain-the-child-element title="obtain the child element">the
<code>div</code> child element</a> of <var title="">element</var>, in
the <a href=#html-namespace>HTML namespace</a>.

</li><li>Otherwise, return the <a href=#context-object>context object</a>.

</li></ol>
</section>

<section>
<h3 id=the-atompersonconstruct-interface><span class=secno>4.3 </span>The <a href=#atompersonconstruct><code>AtomPersonConstruct</code></a> interface</h3>

<pre class=idl><code>[NoInterfaceObject]
interface <dfn id=atompersonconstruct>AtomPersonConstruct</dfn> : <a href=#atomelement>AtomElement</a> {
  attribute <span>DOMString</span> <a href=#dom-atompersonconstruct-name title=dom-AtomPersonConstruct-name>name</a>;
  readonly attribute <span>AtomNameElement</span>? <a href=#dom-atompersonconstruct-nameelement title=dom-AtomPersonConstruct-nameElement>nameElement</a>;
  attribute <span>DOMString</span> <a href=#dom-atompersonconstruct-uri title=dom-AtomPersonConstruct-uri>uri</a>;
  attribute <span>DOMString</span> <a href=#dom-atompersonconstruct-email title=dom-AtomPersonConstruct-email>email</a>;
};</code></pre>

<p>The <dfn id=dom-atompersonconstruct-name title=dom-AtomPersonConstruct-name><code>name</code></dfn>
attribute <em class=rfc2119>MUST</em> <a href=#reflect-the-string-value-of-a-child-element title="reflect the string
value of a child element">reflect the string value of the
<code>name</code> child element</a>.

</p><p>The <dfn id=dom-atompersonconstruct-nameelement title=dom-AtomPersonConstruct-nameElement><code>nameElement</code></dfn>
attribute <em class=rfc2119>MUST</em> return <a href=#obtain-the-child-element title="obtain the
child element">the <code>name</code> child element</a>.

</p><p>The <dfn id=dom-atompersonconstruct-uri title=dom-AtomPersonConstruct-uri><code>uri</code></dfn>
attribute <em class=rfc2119>MUST</em> <a href=#reflect-the-url-value-of-a-child-element title="reflect the URL
value of a child element">reflect the URL value of the
<code>uri</code> child element</a>.

</p><p>The <dfn id=dom-atompersonconstruct-email title=dom-AtomPersonConstruct-email><code>email</code></dfn> attribute
<em class=rfc2119>MUST</em> <a href=#reflect-the-string-value-of-a-child-element title="reflect the string value of a
child element">reflect the string value of the <code>name</code> child
element</a>.

</p></section>

<section>
<h3 id=the-atomdateconstruct-interface><span class=secno>4.4 </span>The <a href=#atomdateconstruct><code>AtomDateConstruct</code></a> interface</h3>

<pre class=idl><code>[NoInterfaceObject]
interface <dfn id=atomdateconstruct>AtomDateConstruct</dfn> : <a href=#atomelement>AtomElement</a> {
  attribute <span>DOMTimeStamp</span> <a href=#dom-atomdateconstruct-value title=dom-AtomDateConstruct-value>value</a>;
};</code></pre>

<p>On getting, the <dfn id=dom-atomdateconstruct-value title=dom-AtomDateConstruct-value><code>value</code></dfn> attribute
of the <a href=#atomdateconstruct><code>AtomDateConstruct</code></a> interface <em class=rfc2119>MUST</em> <a href=#parse-a-global-date-and-time-string title="parse a global date and time
string">parse</a> the <a href=#dom-node-textcontent><code title=dom-Node-textContent>textContent</code></a> of the <a href=#context-object>context
object</a> and return the result (or zero if failed).  <span class=ed>Implementations are required to implement more tolerant
datetime parsing algorithm for compatibility with Atom documents in
the wild...</span>

</p><p>On setting, the <a href=#dom-atomdateconstruct-value><code title=dom-AtomDateConstruct-value>value</code></a> attribute of the
<a href=#atomdateconstruct><code>AtomDateConstruct</code></a> interface <em class=rfc2119>MUST</em>
act as if the <a href=#dom-node-textcontent><code title=dom-Node-textContent>textContent</code></a>
attribute is set to the <a href=#valid-normalized-forced-utc-global-date-and-time-string>valid normalized forced-UTC global date
and time string</a> representation of the given value.
</p></section>

<section>
<h3 id=the-atomfeedelement-interface><span class=secno>4.5 </span>The <a href=#atomfeedelement><code>AtomFeedElement</code></a> interface</h3>

<p>The <a href=#concept-element-interface title=concept-element-interface>element interface</a>
for the <code>feed</code> <a href=#concept-element title=concept-element>element</a>
in the <a href=#atom-namespace>Atom namespace</a> is <a href=#atomfeedelement><code>AtomFeedElement</code></a>.

</p><pre class=idl><code>interface <dfn id=atomfeedelement>AtomFeedElement</dfn> : <a href=#atomelement>AtomElement</a> {
  readonly attribute <a href=#htmlcollection>HTMLCollection</a> <a href=#dom-atomfeedelement-authorelements title=dom-AtomFeedElement-authorElements>authorElements</a>;
  readonly attribute <a href=#htmlcollection>HTMLCollection</a> <a href=#dom-atomfeedelement-categoryelements title=dom-AtomFeedElement-categoryElements>categoryElements</a>;
  readonly attribute <a href=#htmlcollection>HTMLCollection</a> <a href=#dom-atomfeedelement-contributorelements title=dom-AtomFeedElement-contributorElements>contributorElements</a>;
  readonly attribute <span>AtomGeneratorElement</span>? <a href=#dom-atomfeedelement-generatorelement title=dom-AtomFeedElement-generatorElement>generatorElement</a>;
};</code></pre>

<p>The <dfn id=dom-atomfeedelement-authorelements title=dom-AtomFeedElement-authorElements><code>authorElements</code></dfn>
attribute of the <a href=#atomfeedelement><code>AtomFeedElement</code></a> interface <em class=rfc2119>MUST</em> return the <code>author</code> <a href=#child-element-list>child
element list</a> for the <a href=#context-object>context object</a>.

</p><p>The <dfn id=dom-atomfeedelement-categoryelements title=dom-AtomFeedElement-categoryElements><code>categoryElements</code></dfn>
attribute of the <a href=#atomfeedelement><code>AtomFeedElement</code></a> interface <em class=rfc2119>MUST</em> return the <code>category</code> <a href=#child-element-list>child
element list</a> for the <a href=#context-object>context object</a>.

</p><p>The <dfn id=dom-atomfeedelement-contributorelements title=dom-AtomFeedElement-contributorElements><code>contributorElements</code></dfn>
attribute of the <a href=#atomfeedelement><code>AtomFeedElement</code></a> interface <em class=rfc2119>MUST</em> return the <code>contributor</code>
<a href=#child-element-list>child element list</a> for the <a href=#context-object>context object</a>.

</p><p>The <dfn id=dom-atomfeedelement-generatorelement title=dom-AtomFeedElement-generatorElement><code>generatorElement</code></dfn>
attribute <em class=rfc2119>MUST</em> return <a href=#obtain-the-child-element title="obtain the
child element">the <code>generator</code> child element</a>.

</p><p class=ed>
      atom:entry children MUST be placed after any other elements.
      Attributes creating children should insert them before any
      entries?

</p></section>

</section>

<xmp class=ed>
  @Attr:
    @@Name: icon
    @@enDesc:
      The <XE::atom|icon> value of the feed.

      It <kwd:MUST> <I::reflect the URI value
      of the <XE::atom|icon> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{getReflectURIValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'icon',
          $r => $r,
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectURIValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'icon',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomFeedElement.icon.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'feed');

        $test->id ('default');
        $test->assert_null ($el-><AG::AtomFeedElement.icon>);

        $test->id ('set');
        $el-><AS::AtomFeedElement.icon> ('http://example.com/');
        $test->assert_equals ($el-><AG::AtomFeedElement.icon>,
                              'http://example.com/');

        $test->id ('relative');
        $el-><AS::AtomFeedElement.icon> ('favicon.ico');
        $test->assert_equals ($el-><AG::AtomFeedElement.icon>,
                              'favicon.ico');

        $test->id ('relative.base');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          'http://www.example.com/');
        $test->assert_equals ($el-><AG::AtomFeedElement.icon>,
                              'http://www.example.com/favicon.ico');

        $test->id ('multiple');
        $el-><M::Node.appendChild>
               ($doc-><M::Document.createElementNS> (<Q::atom|>, 'icon'))
           -><AS::Node.textContent> ('/default.ico'); # ignored
        $test->assert_equals ($el-><AG::AtomFeedElement.icon>,
                              'http://www.example.com/favicon.ico');

        $test->id ('remove');
        $el-><AS::AtomFeedElement.icon> (null);
        $test->assert_null ($el-><AG::AtomFeedElement.icon>);

  @Attr:
    @@Name: id
    @@enDesc:
      The <XE::atom|id> value of the feed.

      It <kwd:MUST> <I::reflect the string value
      of the <XE::atom|id> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{getReflectStringValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'id',
          $r => $r,
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectStringValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'id',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomFeedElement.id.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'feed');

        $test->id ('default');
        $test->assert_null ($el-><AG::AtomFeedElement.id>);

        $test->id ('set');
        $el-><AS::AtomFeedElement.id> ('http://example.com/');
        $test->assert_equals ($el-><AG::AtomFeedElement.id>,
                              'http://example.com/');

        $test->id ('relative');
        $el-><AS::AtomFeedElement.id> ('favicon.ico');
        $test->assert_equals ($el-><AG::AtomFeedElement.id>,
                              'favicon.ico');

        $test->id ('relative.base');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          'http://www.example.com/');
        $test->assert_equals ($el-><AG::AtomFeedElement.id>,
                              'favicon.ico');

        $test->id ('multiple');
        $el-><M::Node.appendChild>
               ($doc-><M::Document.createElementNS> (<Q::atom|>, 'id'))
           -><AS::Node.textContent> ('/default.ico'); # ignored
        $test->assert_equals ($el-><AG::AtomFeedElement.id>,
                              'favicon.ico');

        $test->id ('remove');
        $el-><AS::AtomFeedElement.id> (null);
        $test->assert_null ($el-><AG::AtomFeedElement.id>);

  @Attr:
    @@Name: linkElements
    @@enDesc:
      A static list of <XE::atom|link> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|link> child element list>
        of the node.
      @@@PerlDef:
        __CODE{returnChildElementList::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'link',
          $r => $r,
        }__;

  @Attr:
    @@Name: logo
    @@enDesc:
      The <XE::atom|logo> value of the feed.

      It <kwd:MUST> <I::reflect the URI value
      of the <XE::atom|logo> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{getReflectURIValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'logo',
          $r => $r,
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectURIValue::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'logo',
          $given => $given,
        }__;

  @Attr:
    @@Name: rightsElement
    @@enDesc:
      The <XE::atom|rights> child element of the node.
    @@Type: AtomRightsElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|rights> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'rights',
          $r => $r,
        }__;

  @Attr:
    @@Name: subtitleElement
    @@enDesc:
      The <XE::atom|subtitle> child element of the node.
    @@Type: AtomSubtitleElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|subtitle> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'subtitle',
          $r => $r,
        }__;

  @Attr:
    @@Name: titleElement
    @@enDesc:
      The <XE::atom|title> child element of the node.
    @@Type: AtomTitleElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|title> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'title',
          $r => $r,
        }__;

  @Attr:
    @@Name: updatedElement
    @@enDesc:
      The <XE::atom|updated> child element of the node.
    @@Type: AtomUpdatedElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|updated> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'updated',
          $r => $r,
        }__;

  @Attr:
    @@Name: entryElements
    @@enDesc:
      A static list of <XE::atom|entry> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|entry> child element list>
        of the node.
      @@@PerlDef:
        __CODE{returnChildElementList::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'entry',
          $r => $r,
        }__;

  @Method:
    @@Name: getEntryElementById
    @@enDesc:
      Returns an <XE::atom|entry> node selected by its <XE::atom|id>.
    @@Param:
      @@@Name: idArg
      @@@Type: DOMString
      @@@actualType: DOMURI
      @@@enDesc:
        The identifier of the entry.
    @@Return:
      @@@Type: AtomEntryElement
      @@@enDesc:
        The <XE::atom|entry> element whose identifier equals to
        <P::id>.

        It <kwd:MUST> return the first child element node in document
        order whose element type is <XE::atom|entry> and
        whose first child element node in document order
        with element type <XE::atom|id> has <A::Node.textContent>
        equals to <P::id>, if any, or <DOM::null>.
      @@@nullCase:
        @@@@enDesc:
          If no matching element.
      @@@PerlDef:
        E: {
          no warnings 'uninitialized';
          for my $cn (@{$self-><AG::Node.childNodes>}) {
            if ($cn-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                $cn-><AG::Node.localName> eq 'entry' and
                $cn-><AG::Node.namespaceURI> eq <Q::atom|>) {
              if ($cn-><AG::AtomEntryElement.id> eq $idArg) {
                $r = $cn;
                last E;
              }
            }
          }
        } # E

  @Method:
    @@Name: addNewEntry
    @@enDesc:
      Creates an <XA::atom|entry> element node and 
      appends to the node.
    @@Param:
      @@@Name: id
      @@@Type: DOMString
      @@@actualType: DOMURI
      @@@enDesc:
        The <XE::atom|id> of the entry.
    @@Param:
      @@@Name: title
      @@@Type: DOMString
      @@@enDesc:
        The <XE::atom|title> of the entry.
      @@@nullCase:
        @@@@enDesc:
          The implementation <kwd:MUST> treate <DOM::null>
          as if an empty string is specified.
    @@Param:
      @@@Name: lang
      @@@Type: DOMString
      @@@enDesc:
        The natural language of the entry.
      @@@nullCase:
        @@@@enDesc:
          No explicit language specification is added.
    @@Return:
      @@@Type: AtomEntryElement
      @@@enDesc:
        The newly created <XE::atom|entry> element.

        {P:: The newly created <XE::atom|entry> element node <kwd:MUST>
             have attributes set as:

           - <A::Node.attributes>::: A <IF::NamedNodeMap> that contains
                                     at least a new <XA::xml|lang>
                                     attribute node except when
                                     the <P::lang> parameter is set
                                     to <DOM::null>.

           - <A::Node.childNodes>::: A <IF::NodeList> containing
                                     a new <XE::atom|id> element node,
                                     a new <XE::atom|title> element node, and
                                     a new <XE::atom|updated> element node
                                     in any order.

        }

        This element node <kwd:MUST> be appended to the node
        as if the <M::Node.appendChild> method were invoked
        on the node and <kwd:MUST> be returned by the method.
        Note that an exception might be thrown during this course.

        {P:: The <XA::xml|lang> attribute node, if created, <kwd:MUST>
             have attributes set as:

           - <A::Node.nodeValue>::: <P::lang>.

           - <A::Attr.specified>::: <DOM::true>.

        }

        {P:: The newly created <XE::atom|id> element node <kwd:MUST>
             have attributes set as:

           - <A::Node.textContent>::: <P::id>.

        }

        {P:: The newly created <XE::atom|title> element node <kwd:MUST>
             have attributes set as:

           - <A::Node.textContent>::: <P::title>.

        }

        The <XA::type> attribute node <kwd:MUST-NOT> be attached
        to the <XE::atom|title> element node.

        {P:: The newly created <XE::atom|updated> element node <kwd:MUST>
             have attributes set as:

           - <A::Node.textContent>::: A uppercase RFC 3339 <CODE::date-time>
             representation of the time when the method is invoked.
             The implementation <kwd:MAY> align its timezone to
             that of the environment in which the method is invoked.

        }
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;

          $r = $od-><M::Document.createElementNS> (<Q::atom|>, 'entry');
          $r-><AS::Node.manakaiLanguage> ($lang) if defined $lang;

          $r-><AS::AtomFeedElement.id> ($id);

          my $titlee = $od-><M::Document.createElementNS> (<Q::atom|>, 'title');
          $titlee-><AS::Node.textContent> (defined $title ? $title : '');
          $r-><M::Node.appendChild> ($titlee);

          my $updatede = $od-><M::Document.createElementNS>
                                (<Q::atom|>, 'updated');
          $updatede-><AS::AtomDateConstruct.value> (scalar time);
          $r-><M::Node.appendChild> ($updatede);

          $self-><M::Node.appendChild> ($r);
        }__;

    @@Test:
      @@@QName: AtomFeedElement.addNewEntry.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $feed = $doc-><M::Document.createElementNS> (<Q::atom|>, 'feed');

        my $ent = $feed-><M::AtomFeedElement.addNewEntry>
                           ('about:id', 'entry title', 'en');

        $test->id ('entry.interface');
        $test->assert_isa ($ent, <IFName::AtomEntryElement>);

        $test->id ('entry.namespaceURI');
        $test->assert_equals ($ent-><AG::Node.namespaceURI>, <Q::atom|>);

        $test->id ('entry.localName');
        $test->assert_equals ($ent-><AG::Node.localName>, 'entry');

        $test->id ('entry.lang');
        $test->assert_equals ($ent-><M::Element.getAttributeNS>
                                         (<Q::xml|>, 'lang'),
                              'en');

        my $id;
        my $title;
        my $updated;

        for my $cn (@{$ent-><AG::Node.childNodes>}) {
          if ($cn-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
              $cn-><AG::Node.namespaceURI> eq <Q::atom|>) {
            if ($cn-><AG::Node.localName> eq 'id') {
              $id = $cn;
            } elsif ($cn-><AG::Node.localName> eq 'title') {
              $title = $cn;
            } elsif ($cn-><AG::Node.localName> eq 'updated') {
              $updated = $cn;
            }
          }
        }
   
        $test->id ('id');
        $test->assert_not_null ($id);

        $test->id ('id.value');
        $test->assert_equals ($id-><AG::Node.textContent>, 'about:id');
   
        $test->id ('title');
        $test->assert_not_null ($title);

        $test->id ('title.value');
        $test->assert_equals ($title-><AG::Node.textContent>, 'entry title');

        $test->id ('title.type');
        $test->assert_null ($title-><M::Element.getAttributeNS> (null, 'type'));
   
        $test->id ('updated');
        $test->assert_not_null ($updated);

        $test->id ('updated.value');
        $test->assert_num_not_equals
                 (actual_value => $updated-><AG::AtomDateConstruct.value>,
                  expected_value => 0);

        $test->id ('parent');
        $test->assert_equals ($ent-><AG::Node.parentNode>, $feed);
    @@Test:
      @@@QName: AtomFeedElement.addNewEntry.2.test
      @@@enDesc:
        <DOM::null> <CODE::lang>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $feed = $doc-><M::Document.createElementNS> (<Q::atom|>, 'feed');

        my $ent = $feed-><M::AtomFeedElement.addNewEntry>
                           ('about:id', 'entry title', null);

        $test->id ('entry.lang');
        $test->assert_null ($ent-><M::Element.getAttributeNS>
                                    (<Q::xml|>, 'lang'));
##AtomFeedElement
</xmp>

<xmp class=ed>


  @CODE:
    @@QName: getReflectAttrURIValue
    @@enDesc:
      {P:: If a DOM attribute is defined to <DFN::reflect the URI value
           of the <VAR::attr-name> attribute> of the node <VAR::E>,
           the getter of the attribute <kwd:MUST> return the value
           defined by the algorithm:

         = Get the string <VAR::S> that would be returned
           if the DOM attribute <I::reflects the string value
           of the <VAR::attr-name> attribute> of the <VAR::E>.

         = If the <VAR::S> is <DOM::null>, it <kwd:MUST> return
           <DOM::null>.

         = Otherwise, if the <A::Node.baseURI> of the node
           from which the <VAR::S> comes is <DOM::null>,
           it <kwd:MUST> return the <VAR::S>.

         = Otherwise, a string that would be returned by the
           <M::urigen|URIReference.getAbsoluteReference>
           method on a <IF::urigen|URIReference> object whose
           <A::urigen|URIReference.uriReference> value
           equals to <A::Node.textContent> with the <CODE::base> parameter
           set to the <A::Node.baseURI> of the node
           from which the <VAR::S> comes and the <CODE::nonStrict>
           parameter set to <DOM::false>.

      }
    @@PerlDef:
      __DEEP{
        my $__attr = $node-><M::Element.getAttributeNodeNS> 
                              ($namespaceURI, $localName);
        if (defined $__attr) {
          my $__attr_base = $__attr-><AG::Node.baseURI>;
          if (defined $__attr_base) {
            $r = $node-><AG::Node.ownerDocument>
                      -><AG::Document.implementation>
                      -><M::urigen|URIImplementation.createURIReference>
                          ($__attr-><AG::Node.nodeValue>)
                      -><M::urigen|URIReference.getAbsoluteReference>
                          ($__attr_base)
                      -><AG::urigen|URIReference.uriReference>;
          } else {
            $r = $__attr-><AG::Node.nodeValue>;
          }
        } else {
          $r = null;
        }
      }__;

  @CODE:
    @@QName: setReflectAttrURIValue
    @@enDesc:
      If a DOM attribute is defined to <DFN::reflect the URI value
      of the <VAR::attr-name> attribute> of the node <VAR::E>,
      the setter of the DOM attribute <kwd:MUST> modify the node as
      if the DOM attribute <I::reflects the string value of
      the <VAR::attr-name> attribute> of the <VAR::E>.

        {NOTE::
          It might throw an exception.
        }
    @@PerlDef:
      __CODE{setReflectAttrStringValue}__;

  @enImplNote:
    @@ddid: datereflect
    @@@:
      {ISSUE::
        <QUOTE::reflecting Date child element> attribute should
        be provided for published and created?
      }

  @CODE:
    @@QName: getReflectAttrNonNegativeIntegerValue
    @@enDesc:
      {P:: If a DOM attribute is defined to <DFN::reflect the 
           non-negative integer value of the <VAR::attr-name> attribute>
           of the node <VAR::E>, the getter of the attribute <kwd:MUST>
           return the value defined by the algorithm:

        {OLI:: If the <VAR::E> contains an attribute node <VAR::A> whose name
               is <VAR::attr-name>:

          = If the <A::Node.nodeValue> of the <VAR::A> is
            one or more sequence of digits (<CHAR::DIGIT ZERO>, 
            <CHAR::DIGIT ONE>, ..., <CHAR::DIGIT NINE>) optionally
            preceding by a <CHAR::PLUS SIGN>, then
            the attribute getter <kwd:MUST> return a value
            by interpreting the <A::Node.nodeValue> of the <VAR::A>
            as a decimal number.

        }

        = If a default value is explicitly defined
          where this algorithm is referenced, it <kwd:MUST>
          return the default value.

        = Otherwise, it <kwd:MUST> return a binding-specific
          default value, if it is defined by the specification
          of the binding, or <DOM::-1>.

      }

        {NOTE::
          In Atom Threading Extension <SRC::RFC 4685>,
          the <CHAR::PLUS SIGN> and leading <CHAR::DIGIT ZERO>s
          are prohibitted.
        }
    @@PerlDef:
      __DEEP{
        E: {
          $r = $node-><M::Element.getAttributeNS> ($namespaceURI, $localName);
          if (defined $r) {
            if ($r =~ /\A\+?([0-9]+)\z/) {
              $r = 0+$1;
              last E;
            }
          }

          $r = $defaultValue;
          $r = -1 unless defined $r;
        } # E
      }__;

  @CODE:
    @@QName: setReflectAttrNonNegativeIntegerValue
    @@enDesc:
      {P:: If a DOM attribute is defined to <DFN::reflect the
           non-negative integer value
           of the <VAR::attr-name> attribute> of the node <VAR::E>,
           the setter of the attribute <kwd:MUST> modify the node as
           defined by the algorithm:

        = If the given value is <DOM::-1> or one of binding-specific
          default values, if any, as defined by the specification
          of the binding, it <kwd:MUST>
          remove the <VAR::attr-name> attribute node, if any,
          from the list of attribute nodes of <VAR::E>.

        = Otherwise, it <kwd:MUST> set the <VAR::attr-name>
          attribute node value to a string representation
          of the given value as if 
          the <M::Element.setAttributeNS> method were invoked.
          The string representation <kwd:MUST> be a decimal
          number consist of one or more sequence of digits
          (<CHAR::DIGIT ZERO>, <CHAR::DIGIT ONE>, ..., <CHAR::DIGIT NINE>)
          <EM::without> any leading <CHAR::DIGIT ZERO>.
          The <CHAR::PLUS SIGN> <kwd:MUST> be omitted.

      }

        {NOTE::
          It might throw an exception.
        }
    @@PerlDef:
      __DEEP{
        if (defined $given and $given >= 0) {
          $node-><M::Element.setAttributeNS>
                   ($namespaceURI, $localName, 0+$given);
        } else {
          $node-><M::Element.removeAttributeNS> ($namespaceURI, $localName);
        }
      }__;
##AtomImplementation

ECDef:
  @QName: entry-prop
  @mv:elementTypeClassName: entry-prop
  @mv:refers: atom|author
  @mv:refers: atom|category
  @mv:refers: atom|content
  @mv:refers: atom|contributor
  @mv:refers: atom|id
  @mv:refers: atom|link
  @mv:refers: atom|published
  @mv:refers: atom|rights
  @mv:refers: atom|source
  @mv:refers: atom|summary
  @mv:refers: atom|title
  @mv:refers: atom|updated
  @mv:refers: extensionElements

IFClsETDef:
  @IFQName: AtomEntryElement
  @ETQName: atom|entry
  @ETRQName: atom|entry
  @ClsQName: ManakaiAtomEntryElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm:
    (entry-prop+)

  @enDesc:
    The <XE::atom|entry> element represents an individual
    entry, acting as a container for metadata and data
    associated with the entry.

  @Attr:
    @@Name: authorElements
    @@enDesc:
      A static list of <XE::atom|author> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|author> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.authorElements.get

  @Attr:
    @@Name: entryAuthorElements
    @@enDesc:
      A static list of <XE::atom|author> elements for the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        = If the node contains one or more <XE::atom|author>
          element node in its child node list, then it
          <kwd:MUST> return a <IF::StaticNodeList> that
          would be returned by the <A::AtomEntryElement.authorElements>
          attribute of the node.

        = Otherwise, if the node contains a <XE::atom|source>
          element node in its child node list, then it 
          <kwd:MUST> return a <IF::StaticNodeList> that
          would be returned by the <A::AtomSourceElement.authorElements>
          attribute of that node, unless its <A::NodeList.length>
          is zero.

        = Otherwise, if the <A::Node.parentNode> of the
          node is a <XE::atom|feed> element node, then
          it <kwd:MUST> return a <IF::StaticNodeList> that
          would be returned by the <A::AtomFeedElement.authorElements>
          attribute of that node.

        = Otherwise, it <kwd:MUST> return a <IF::StaticNodeList>
          whose <A::NodeList.length> is zero.
      @@@PerlDef:
        __DEEP{
          E: {
            no warnings 'uninitialized';
            __CODE{tc|createStaticNodeList:: $r => $r}__;
  
            my $source;
            for my $cn (@{$self-><AG::Node.childNodes>}) {
              if ($cn-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  $cn-><AG::Node.namespaceURI> eq <Q::atom|>) {
                if ($cn-><AG::Node.localName> eq 'author') {
                  push @{$r}, $cn;
                } elsif ($cn-><AG::Node.localName> eq 'source') {
                  $source = $cn;
                }
              }
            }
            last E unless @{$r} == 0;
  
            if (defined $source) {
              $r = $source-><AG::AtomSourceElement.authorElements>;
            }
            last E unless @{$r} == 0;

            my $parent = $self-><AG::Node.parentNode>;
            if (defined $parent and
                $parent-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                $parent-><AG::Node.namespaceURI> eq <Q::atom|> and
                $parent-><AG::Node.localName> eq 'feed') {
              $r = $parent-><AG::AtomFeedElement.authorElements>;
            }
          } # E
        }__;

    @@Test:
      @@@QName: AtomEntryElement.entryAuthorElements.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');


        $test->id ('empty');
        my $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 0);

        $test->id ('one');
        $el-><M::Node.appendChild>
               ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
        $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 1);

        $test->id ('source');
        for ($el-><M::Node.appendChild>
                    ($doc-><M::Document.createElementNS>
                             (<Q::atom|>, 'source'))) {
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
        }
        $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 1);

        $test->id ('parent');
        for ($doc-><M::Document.createElementNS> (<Q::atom|>, 'feed')) {
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild> ($el);
        }
        $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 1);
    @@Test:
      @@@QName: AtomEntryElement.entryAuthorElements.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');

        $test->id ('source');
        for ($el-><M::Node.appendChild>
                    ($doc-><M::Document.createElementNS>
                             (<Q::atom|>, 'source'))) {
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
        }
        my $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 2);

        $test->id ('parent');
        for ($doc-><M::Document.createElementNS> (<Q::atom|>, 'feed')) {
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild> ($el);
        }
        $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 2);
    @@Test:
      @@@QName: AtomEntryElement.entryAuthorElements.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');

        $test->id ('source');
        for ($el-><M::Node.appendChild>
                    ($doc-><M::Document.createElementNS>
                             (<Q::atom|>, 'source'))) {
          # empty
        }
        my $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 0);

        $test->id ('parent');
        my $parent;
        for ($doc-><M::Document.createElementNS> (<Q::atom|>, 'feed')) {
          $parent = $_;
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild> ($el);
        }
        $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 3);
    @@Test:
      @@@QName: AtomEntryElement.entryAuthorElements.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');

        $test->id ('parent');
        my $parent;
        for ($doc-><M::Document.createElementNS> (<Q::atom|>, 'feed')) {
          $parent = $_;
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild>
                ($doc-><M::Document.createElementNS> (<Q::atom|>, 'author'));
          $_-><M::Node.appendChild> ($el);
        }
        my $list = $el-><AG::AtomEntryElement.entryAuthorElements>;
        $test->assert_num_equals (actual_value => 0+@$list, expected_value => 3);

  @Attr:
    @@Name: categoryElements
    @@enDesc:
      A static list of <XE::atom|category> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|category> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.categoryElements.get

  @Attr:
    @@Name: contentElement
    @@enDesc:
      The <XE::atom|content> child element of the node.
    @@Type: AtomContentElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|content> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'content',
          $r => $r,
        }__;

  @Attr:
    @@Name: contributorElements
    @@enDesc:
      A static list of <XE::atom|contributor> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|contributor> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.contributorElements.get

  @Attr:
    @@Name: id
    @@enDesc:
      The <XE::atom|id> value of the feed.

      It <kwd:MUST> <I::reflect the string value
      of the <XE::atom|id> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.id.get
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.id.set

  @Attr:
    @@Name: linkElements
    @@enDesc:
      A static list of <XE::atom|link> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|link> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.linkElements.get

  @Attr:
    @@Name: publishedElement
    @@enDesc:
      The <XE::atom|published> child element of the node.
    @@Type: AtomPublishedElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|published> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'published',
          $r => $r,
        }__;

  @Attr:
    @@Name: rightsElement
    @@enDesc:
      The <XE::atom|rights> child element of the node.
    @@Type: AtomRightsElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|rights> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.rightsElement.get

  @Attr:
    @@Name: entryRightsElement
    @@enDesc:
      The <XE::atom|rights> element for the node.
    @@Type: AtomRightsElement
    @@Get:
      @@@enDesc:
        = If the node contains a <XE::atom|rights>
          element node in its child node list, then it
          <kwd:MUST> return the first such a node in document order.

        = Otherwise, if the <A::Node.parentNode> of the
          node is a <XE::atom|feed> element node, then
          it <kwd:MUST> return an <IF::AtomRightsElement>
          that would be returned by the <A::AtomFeedElement.rightsElement>
          attribute of that node, except when it is <DOM::null>.

        {OLI:: Otherwise,

          {OLI:: If the <cfg::cfg|create-child-element> configuration
                 parameter is set to <DOM::true>,

             = Create an element node <VAR::N> whose element type
               is <XE::atom|rights>.

             = Append <VAR::N> to this node as if the <M::Node.appendChild>
               method were called for the node with its parameter
               set to <VAR::N>.  Note that this might throw an exception.

             = Then, <VAR::N> <kwd:MUST> be returned.

          }

          = Otherwise, it <kwd:MUST> return <DOM::null>.
        }
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          E: {
            no warnings 'uninitialized';
            for my $cn (@{$self-><AG::Node.childNodes>}) {
              if ($cn-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  $cn-><AG::Node.localName> eq 'rights' and 
                  $cn-><AG::Node.namespaceURI> eq <Q::atom|>) {
                $r = $cn;
                last E;
              }
            }

            my $parent = $self-><AG::Node.parentNode>;
            if (defined $parent and
                $parent-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                $parent-><AG::Node.namespaceURI> eq <Q::atom|> and
                $parent-><AG::Node.localName> eq 'feed') {
              for my $cn (@{$parent-><AG::Node.childNodes>}) {
                if ($cn-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                    $cn-><AG::Node.localName> eq 'rights' and 
                    $cn-><AG::Node.namespaceURI> eq <Q::atom|>) {
                  $r = $cn;
                  last E;
                }
              }
            }

            my $od = $self-><AG::Node.ownerDocument>;
            if ($od-><AG::Document.domConfig>
                   -><M::CFG.getParameter> (<Q::cfg|create-child-element>)) {
              $r = $od-><M::Document.createElementNS> (<Q::atom|>, 'rights');
              $self-><M::Node.appendChild> ($r);
            }
          } # E
        }__;

    @@Test:
      @@@QName: AtomEntryElement.entryRightsElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');

        $test->id ('no');
        my $rights = $el-><AG::AtomEntryElement.entryRightsElement>;
        $test->assert_null ($rights);

        $doc-><AG::Document.domConfig>
            -><M::CFG.setParameter> (<Q::cfg|create-child-element> => true);

        $rights = $el-><AG::AtomEntryElement.entryRightsElement>;

        $test->id ('created.namespaceURI');
        $test->assert_equals ($rights-><AG::Node.namespaceURI>, <Q::atom|>);

        $test->id ('created.localName');
        $test->assert_equals ($rights-><AG::Node.localName>, 'rights');

        $test->id ('created.parentNode');
        $test->assert_equals ($rights-><AG::Node.parentNode>, $el);

        $test->id ('get');
        my $rights2 = $el-><AG::AtomEntryElement.entryRightsElement>;
        $test->assert_equals ($rights2, $rights);
    @@Test:
      @@@QName: AtomEntryElement.entryRightsElement.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'entry');

        my $feed = $doc-><M::Document.createElementNS> (<Q::atom|>, 'feed');
        $feed-><M::Node.appendChild> ($el);
        my $rights = $doc-><M::Document.createElementNS> (<Q::atom|>, 'rights');
        $feed-><M::Node.appendChild> ($rights);

        $test->id ('get');
        my $rights2 = $el-><AG::AtomEntryElement.entryRightsElement>;
        $test->assert_equals ($rights2, $rights);

  @Attr:
    @@Name: sourceElement
    @@enDesc:
      The <XE::atom|source> child element of the node.
    @@Type: AtomSourceElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|source> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'source',
          $r => $r,
        }__;

  @Attr:
    @@Name: summaryElement
    @@enDesc:
      The <XE::atom|summary> child element of the node.
    @@Type: AtomSummaryElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|summary> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{returnChildElement::
          $node => $self,
          $namespaceURI => {<Q::atom|>},
          $localName => 'summary',
          $r => $r,
        }__;

  @Attr:
    @@Name: titleElement
    @@enDesc:
      The <XE::atom|title> child element of the node.
    @@Type: AtomTitleElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|title> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.titleElement.get

  @Attr:
    @@Name: updatedElement
    @@enDesc:
      The <XE::atom|updated> child element of the node.
    @@Type: AtomUpdatedElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|updated> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.updatedElement.get
##AtomEntryElement

IFClsETDef:
  @IFQName: AtomIdElement
  @ETQName: atom|id
  @ETRQName: atom|id
  @ClsQName: ManakaiAtomIdElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes
  
  @cm: atomUriCM
##AtomIdElement

IFClsETDef:
  @IFQName: AtomIconElement
  @ETQName: atom|icon
  @ETRQName: atom|icon
  @ClsQName: ManakaiAtomIconElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm: atomUriCM
##AtomIconElement

IFClsETDef:
  @IFQName: AtomNameElement
  @ETQName: atom|name
  @ETRQName: atom|name
  @ClsQName: ManakaiAtomNameElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  # no common attribs
  @cm: TextCM

  @mv:refers: Atom
##AtomNameElement

IFClsETDef:
  @IFQName: AtomUriElement
  @ETQName: atom|uri
  @ETRQName: atom|uri
  @ClsQName: ManakaiAtomUriElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  # no common attribs
  @cm: atomUriCM

  @mv:refers: Atom
##AtomUriElement

IFClsETDef:
  @IFQName: AtomEmailElement
  @ETQName: atom|email
  @ETRQName: atom|email
  @ClsQName: ManakaiAtomEmailElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  # no common attribs
  @cm: atomEmailAddressCM

  @mv:refers: Atom
##AtomEmailElement

IFClsETDef:
  @IFQName: AtomLogoElement
  @ETQName: atom|logo
  @ETRQName: atom|logo
  @ClsQName: ManakaiAtomLogoElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm: atomUriCM
##AtomLogoElement

IFClsETDef:
  @IFQName: AtomContentElement
  @ETQName: atom|content
  @ETRQName: atom|content
  @ClsQName: ManakaiAtomContentElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm:
    dxm|ANY

  @enDesc:
    The <XE::atom|content> element either contains or links to
    the content of the entry.

  @ATTR:
    @@Name: type
    @@enDesc:
      The type of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::type> attribute> of the node.  It default
      value <kwd:MUST> be <CODE::text> if and only if
      there is no <XA::src> attribute on the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $r => $r,
          $defaultValue => {
            $self-><M::Element.hasAttributeNS> (null, 'src') ? null : 'text'
          },
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomContentElement.type.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'content');

        $test->id ('default.no.src');
        $test->assert_equals ($el-><AG::AtomContentElement.type>, 'text');

        $test->id ('default.src');
        $el-><AS::AtomContentElement.src> ('http://atom.example/');
        $test->assert_null ($el-><AG::AtomContentElement.type>);

        $test->id ('set.xhtml');
        $el-><AS::AtomContentElement.type> ('xhtml');
        $test->assert_equals ($el-><AG::AtomContentElement.type>, 'xhtml');

        $test->id ('set.imt');
        $el-><AS::AtomContentElement.type> ('application/xml');
        $test->assert_equals ($el-><AG::AtomContentElement.type>,
                              'application/xml');

        $test->id ('remove');
        $el-><AS::AtomContentElement.type> (null);
        $test->assert_null ($el-><AG::AtomContentElement.type>);

  @ATTR:
    @@Name: src
    @@enDesc:
      The source of the remote content of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::src> attribute> of the node.
    @@Type: DOMString
    @@Type: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'src',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'src',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomContentElement.src.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'content');

        $test->id ('default');
        $test->assert_null ($el-><AG::AtomContentElement.src>);

        $test->id ('set');
        $el-><AS::AtomContentElement.src> ('http://atom.example/');
        $test->assert_equals ($el-><AG::AtomContentElement.src>,
                              'http://atom.example/');

        $test->id ('set.relative');
        $el-><AS::AtomContentElement.src> ('atom');
        $test->assert_equals ($el-><AG::AtomContentElement.src>, 'atom');

        $test->id ('set.relative.base');
        $el-><M::Element.setAttributeNS> (<Q::xml|>, 'xml:base',
                                          'http://atom.example/');
        $test->assert_equals ($el-><AG::AtomContentElement.src>,
                              'http://atom.example/atom');

        $test->id ('remove');
        $el-><AS::AtomContentElement.src> (null);
        $test->assert_null ($el-><AG::AtomContentElement.src>);

  @Attr:
    @@Name: container
    @@enDesc:
      The container element that contains the actual content for the node.
    @@Type: Element
    @@Get:
      @@@enDesc:
        - If the <A::AtomContentElement.type> is <CODE::xhtml>, 
          it <kwd:MUST> <I::return the <XE::html|div> child element>.

        - Otherwise, if the <A::AtomContentElement.src> is <DOM::null>, 
          it <kwd:MUST> return <DOM::null>.

        - Otherwise, it <kwd:MUST> return the node itself.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          my $type = $self-><AG::AtomContentElement.type>;
          if (defined $type and $type eq 'xhtml') {
            __UNDEEP{
              __CODE{returnChildElement::
                $node => $self,
                $namespaceURI => {<Q::html|>},
                $localName => 'div',
                $r => $r,
              }__;
            }__;
          } elsif (not $self-><M::Element.hasAttributeNS> (null, 'src')) {
            $r = $self;
          }
        }__;

    @@Test:
      @@@QName: AtomContentElement.container.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'content');

        $test->id ('no');
        $test->assert_equals ($el-><AG::AtomContentElement.container>, $el);

        $test->id ('application/smil');
        $el-><AS::AtomContentElement.type> ('application/smil');
        $test->assert_equals ($el-><AG::AtomContentElement.container>, $el);

        $test->id ('text');
        $el-><AS::AtomContentElement.type> ('text');
        $test->assert_equals ($el-><AG::AtomContentElement.container>, $el);

        $test->id ('html');
        $el-><AS::AtomContentElement.type> ('html');
        $test->assert_equals ($el-><AG::AtomContentElement.container>, $el);

        $test->id ('xhtml');
        $el-><AS::AtomContentElement.type> ('xhtml');
        $test->assert_null ($el-><AG::AtomContentElement.container>);

        $doc-><AG::Document.domConfig>
            -><M::CFG.setParameter> (<Q::cfg|create-child-element> => true);
        my $con = $el-><AG::AtomContentElement.container>;

        $test->id ('xhtml.create');
        $test->assert_not_equals ($con, $el);

        $test->id ('xhtml.namespaceURI');
        $test->assert_equals ($con-><AG::Node.namespaceURI>, <Q::html|>);

        $test->id ('xhtml.localName');
        $test->assert_equals ($con-><AG::Node.localName>, 'div');

        $test->id ('xhtml.parentNode');
        $test->assert_equals ($con-><AG::Node.parentNode>, $el);

        $test->id ('xhtml.2');
        $test->assert_equals ($el-><AG::AtomContentElement.container>, $con);
    @@Test:
      @@@QName: AtomContentElement.container.2.test
      @@@enDesc:
        With <XA::src>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'content');

        $el-><AS::AtomContentElement.src> ('http://www.example.com/');

        $test->id ('no');
        $test->assert_null ($el-><AG::AtomContentElement.container>);

        $test->id ('application/smil');
        $el-><AS::AtomContentElement.type> ('application/smil');
        $test->assert_null ($el-><AG::AtomContentElement.container>);

  @enImplNote:
    @@ddid: base64
    @@@:
      {TODO::
        Access to Base64'ed content is necessary.
      }
##AtomContentElement

IFClsETDef:
  @IFQName: AtomAuthorElement
  @ETQName: atom|author
  @ETRQName: atom|author
  @ClsQName: ManakaiAtomAuthorElement

  @IFISA: AtomPersonConstruct
  @ClsISA: ManakaiAtomPersonConstruct

  @f:implements: AtomFeature10
  @mv:refers: PersonAG
  @mv:elementContentModel: PersonCM

  @enDesc:
    The <XE::atom|author> element is a Person construct that
    indicates the author of the entry or feed.
##AtomAuthorElement

IFClsETDef:
  @IFQName: AtomCategoryElement
  @ETQName: atom|category
  @ETRQName: atom|category
  @ClsQName: ManakaiAtomCategoryElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm: undefinedContent

  @enDesc:
    The <XE::atom|category> element conveys information abut
    a category associated with an entry or feed.

  @Attr:
    @@Name: term
    @@enDesc:
      The <XA::term> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::term> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'term',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'term',
          $given => $given,
        }__;

  @Attr:
    @@Name: scheme
    @@enDesc:
      The categorization scheme of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::scheme> attribute> of the node.
    @@Type: DOMString
    @@Type: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'scheme',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'scheme',
          $given => $given,
        }__;

  @Attr:
    @@Name: label
    @@enDesc:
      The <XA::label> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::label> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'label',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'label',
          $given => $given,
        }__;
##AtomCategoryElement

IFClsETDef:
  @IFQName: AtomContributorElement
  @ETQName: atom|contributor
  @ETRQName: atom|contributor
  @ClsQName: ManakaiAtomContributorElement

  @IFISA: AtomPersonConstruct
  @ClsISA: ManakaiAtomPersonConstruct

  @f:implements: AtomFeature10
  @mv:refers: PersonAG
  @mv:elementContentModel: PersonCM

  @enDesc:
    The <XE::atom|contributor> element is a Person construct that
    indicates a person or other entity who contributed to the entry
    or feed.
##AtomContributorElement

IFClsETDef:
  @IFQName: AtomGeneratorElement
  @ETQName: atom|generator
  @ETRQName: atom|generator
  @ClsQName: ManakaiAtomGeneratorElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm:
    (dxm|PCDATA)*

  @enDesc:
    The <XE::atom|generator> element identifies the agent used
    to generate a feed.

  @Attr:
    @@Name: uri
    @@enDesc:
      The URI attribute of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::uri> attribute> of the node.
    @@Type: DOMString
    @@Type: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'uri',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'uri',
          $given => $given,
        }__;

  @Attr:
    @@Name: version
    @@enDesc:
      The <XA::version> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::version> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'version',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'version',
          $given => $given,
        }__;
##AtomGeneratorElement

IFClsETDef:
  @IFQName: AtomLinkElement
  @ETQName: atom|link
  @ETRQName: atom|link
  @ClsQName: ManakaiAtomLinkElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm: undefinedContent

  @enDesc:
    The <XE::atom|link> element defines a reference from an entry
    or feed to a Web resource.

  @ATTR:
    @@Name: href
    @@enDesc:
      The <XA::href> attribute of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::href> attribute> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'href',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'href',
          $given => $given,
        }__;

  @ATTR:
    @@Name: rel
    @@enDesc:
      The <XA::rel> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::rel> attribute> of the node, with
      a few exceptions.  The default value <kwd:MUST> 
      be <URI^DISCore|QName::rel|alternate>.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@enDesc:
        If the algorithm returns a string that does not contain
        any <CHAR::COLON> character, the string
        <URI^DISCore|QName::rel|> <kwd:MUST> be prepended
        for the return value of the getter.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'rel',
          $r => $r,
          $defaultValue => {<Q::rel|alternate>},
        }__;
        if (defined $r and index ($r, ':') == -1) {
          $r = <Q::rel|> . $r;
        }
    @@Set:
      @@@enDesc:
        If the given value starts with <URI^DISCore|QName::rel|> (by
        simple character-by-character comparison), such substring
        <kwd:MUST> be removed for the purpose of the setter algorithm, 
        if and only if the result string is not empty and does contain
        none of <CHAR::COLON>, <CHAR::SOLIDUS>, <CHAR::QUESTION MARK>,
        and <CHAR::NUMBER SIGN>.
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        if (defined $given) {
          $given =~ s[\Ahttp://www.iana.org/assignments/relation/([^:/?#]+)\z]
                     [$1];
        }
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'rel',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomLinkElement.rel.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'link');

        $test->id ('default');
        $test->assert_equals ($el-><AG::AtomLinkElement.rel>,
                              <Q::rel|alternate>);

        $test->id ('set');
        $el-><AS::AtomLinkElement.rel> ('http://www.example.com/');
        $test->assert_equals ($el-><AG::AtomLinkElement.rel>,
                              'http://www.example.com/');

        $test->id ('set.self');
        $el-><AS::AtomLinkElement.rel> ('self');
        $test->assert_equals ($el-><AG::AtomLinkElement.rel>,
                              <Q::rel|self>);

        $test->id ('set.qrelated');
        $el-><AS::AtomLinkElement.rel> (<Q::rel|related>);
        $test->assert_equals ($el-><AG::AtomLinkElement.rel>,
                              <Q::rel|related>);

        $test->id ('remove');
        $el-><AS::AtomLinkElement.rel> (null);
        $test->assert_equals ($el-><AG::AtomLinkElement.rel>,
                              <Q::rel|alternate>);

  @ATTR:
    @@Name: type
    @@enDesc:
      The <XA::type> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::type> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        {P:: If the feature <Feature^^DISCore|QName::AtomThreadingFeature10>
             is supported, the attribute getter <kwd:MUST> return
             the string <CODE::application/atom+xml> when both of the
             following conditions are met:

           - The attribute getter would otherwise return <DOM::null>.

           - The <A::AtomLinkElement.rel> attribute contains
             a string value of <URI^^DISCore|QName::rel|replies>.

        }
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $r => $r,
          $defaultValue => {null},
        }__;

        unless (defined $r) {
          __DEEP{
            my $rel = $self-><AG::AtomLinkElement.rel>;
            if (defined $rel and $rel eq <Q::rel|replies>) {
              $r = q<application/atom+xml>;
            }
          }__;
        }
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomLinkElement.type.!rel.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'link');

        $test->id ('implied');
        my $type0 = $el-><AG::AtomLinkElement.type>;
        $test->assert_null ($type0);

        $test->id ('explicit');
        $el-><AS::AtomLinkElement.type> ('application/atom+xml');
        my $type1 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type1, q<application/atom+xml>);

        $test->id ('different');
        $el-><AS::AtomLinkElement.type> ('application/xhtml+xml');
        my $type2 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type2, q<application/xhtml+xml>);
    @@Test:
      @@@QName: AtomLinkElement.type.rel!=replies.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'link');

        $el-><AS::AtomLinkElement.rel> (<Q::rel|alternate>);

        $test->id ('implied');
        my $type0 = $el-><AG::AtomLinkElement.type>;
        $test->assert_null ($type0);

        $test->id ('explicit');
        $el-><AS::AtomLinkElement.type> ('application/atom+xml');
        my $type1 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type1, q<application/atom+xml>);

        $test->id ('different');
        $el-><AS::AtomLinkElement.type> ('application/xhtml+xml');
        my $type2 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type2, q<application/xhtml+xml>);
    @@Test:
      @@@QName: AtomLinkElement.type.rel=replies.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (<Q::atom|>, 'link');

        $el-><AS::AtomLinkElement.rel> (<Q::rel|replies>);

        $test->id ('implied');
        my $type0 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type0, q<application/atom+xml>);

        $test->id ('explicit');
        $el-><AS::AtomLinkElement.type> ('application/atom+xml');
        my $type1 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type1, q<application/atom+xml>);

        $test->id ('different');
        $el-><AS::AtomLinkElement.type> ('application/xhtml+xml');
        my $type2 = $el-><AG::AtomLinkElement.type>;
        $test->assert_equals ($type2, q<application/xhtml+xml>);

  @ATTR:
    @@Name: hreflang
    @@enDesc:
      The <XA::hreflang> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::hreflang> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'hreflang',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'hreflang',
          $given => $given,
        }__;

  @ATTR:
    @@Name: title
    @@enDesc:
      The <XA::title> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::title> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'title',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'title',
          $given => $given,
        }__;

  @ATTR:
    @@Name: length
    @@enDesc:
      The <XA::length> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::length> attribute> of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'length',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'length',
          $given => $given,
        }__;
##AtomLinkElement

IFClsETDef:
  @IFQName: AtomPublishedElement
  @ETQName: atom|published
  @ETRQName: atom|published
  @ClsQName: ManakaiAtomPublishedElement

  @IFISA: AtomDateConstruct
  @ClsISA: ManakaiAtomDateConstruct

  @f:implements: AtomFeature10
  @mv:refers: DateAG
  @mv:elementContentModel: DateCM

  @enDesc:
    The <XE::atom|published> element is a Date construct
    indicating an instant in time associated with an
    event early in the life cycle of the entry.

    Typically, <XE::atom|published> will be associated with
    the initial creation or first availability of the resouce.
##AtomPublishedElement

IFClsETDef:
  @IFQName: AtomRightsElement
  @ETQName: atom|rights
  @ETRQName: atom|rights
  @ClsQName: ManakaiAtomRightsElement

  @IFISA: AtomTextConstruct
  @ClsISA: ManakaiAtomTextConstruct

  @f:implements: AtomFeature10
  @mv:refers: TextAG
  @mv:elementContentModel: TextCM

  @enDesc:
    The <XE::atom|rights> element is a Text construct
    that conveys information about rights held in and
    over an entry or feed.
##AtomRightsElement

ECDef:
  @QName: source-prop
  @mv:elementTypeClassName: source-prop
  @mv:refers: atom|author
  @mv:refers: atom|category
  @mv:refers: atom|contributor
  @mv:refers: atom|generator
  @mv:refers: atom|icon
  @mv:refers: atom|id
  @mv:refers: atom|link
  @mv:refers: atom|logo
  @mv:refers: atom|rights
  @mv:refers: atom|subtitle
  @mv:refers: atom|title
  @mv:refers: atom|updated
  @mv:refers: extensionElements

IFClsETDef:
  @IFQName: AtomSourceElement
  @ETQName: atom|source
  @ETRQName: atom|source
  @ClsQName: ManakaiAtomSourceElement

  @IFISA: AtomElement
  @ClsISA: ManakaiAtomElement

  @f:implements: AtomFeature10
  @mv:refers: atomCommonAttributes

  @cm:
    (source-prop*)

  @Attr:
    @@Name: authorElements
    @@enDesc:
      A static list of <XE::atom|author> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|author> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.authorElements.get

  @Attr:
    @@Name: categoryElements
    @@enDesc:
      A static list of <XE::atom|category> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|category> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.categoryElements.get

  @Attr:
    @@Name: contributorElements
    @@enDesc:
      A static list of <XE::atom|contributor> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|contributor> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.contributorElements.get

  @Attr:
    @@Name: generatorElement
    @@enDesc:
      The <XE::atom|generator> child element of the node.
    @@Type: AtomGeneratorElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|generator> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.generatorElement.get

  @Attr:
    @@Name: icon
    @@enDesc:
      The <XE::atom|icon> value of the node.

      It <kwd:MUST> <I::reflect the URI value
      of the <XE::atom|icon> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.icon.get
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.icon.set

  @Attr:
    @@Name: id
    @@enDesc:
      The <XE::atom|id> value of the node.

      It <kwd:MUST> <I::reflect the string value
      of the <XE::atom|id> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.id.get
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.id.set

  @Attr:
    @@Name: linkElements
    @@enDesc:
      A static list of <XE::atom|link> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|link> child element list>
        of the node.
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.linkElements.get

  @Attr:
    @@Name: logo
    @@enDesc:
      The <XE::atom|logo> value of the node.

      It <kwd:MUST> <I::reflect the URI value
      of the <XE::atom|logo> child element> of the node.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.logo.get
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the value.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.logo.set

  @Attr:
    @@Name: rightsElement
    @@enDesc:
      The <XE::atom|rights> child element of the node.
    @@Type: AtomRightsElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|rights> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.rightsElement.get

  @Attr:
    @@Name: subtitleElement
    @@enDesc:
      The <XE::atom|subtitle> child element of the node.
    @@Type: AtomSubtitleElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|subtitle> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.subtitleElement.get

  @Attr:
    @@Name: titleElement
    @@enDesc:
      The <XE::atom|title> child element of the node.
    @@Type: AtomTitleElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|title> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.titleElement.get

  @Attr:
    @@Name: updatedElement
    @@enDesc:
      The <XE::atom|updated> child element of the node.
    @@Type: AtomUpdatedElement
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::atom|updated> child element>
        of the node.
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@dlp:cloneCode: ManakaiAtomFeedElement.updatedElement.get
##AtomSourceElement

IFClsETDef:
  @IFQName: AtomSubtitleElement
  @ETQName: atom|subtitle
  @ETRQName: atom|subtitle
  @ClsQName: ManakaiAtomSubtitleElement

  @IFISA: AtomTextConstruct
  @ClsISA: ManakaiAtomTextConstruct

  @f:implements: AtomFeature10
  @mv:refers: TextAG
  @mv:elementContentModel: TextCM

  @enDesc:
    The <XE::atom|subtitle> element is a Text construct
    that conveys a human-readable description or subtitle for a feed.
##AtomSubtitleElement

IFClsETDef:
  @IFQName: AtomSummaryElement
  @ETQName: atom|summary
  @ETRQName: atom|summary
  @ClsQName: ManakaiAtomSummaryElement

  @IFISA: AtomTextConstruct
  @ClsISA: ManakaiAtomTextConstruct

  @f:implements: AtomFeature10
  @mv:refers: TextAG
  @mv:elementContentModel: TextCM

  @enDesc:
    The <XE::atom|summary> element is a Text construct
    that conveys a short summary, abstract, or excerpt of an entry.
##AtomSummaryElement

IFClsETDef:
  @IFQName: AtomTitleElement
  @ETQName: atom|title
  @ETRQName: atom|title
  @ClsQName: ManakaiAtomTitleElement

  @IFISA: AtomTextConstruct
  @ClsISA: ManakaiAtomTextConstruct

  @f:implements: AtomFeature10
  @mv:refers: TextAG
  @mv:elementContentModel: TextCM

  @enDesc:
    The <XE::atom|title> element is a Text construct
    that conveys a human-readable title for an entry or feed.
##AtomTitleElement

IFClsETDef:
  @IFQName: AtomUpdatedElement
  @ETQName: atom|updated
  @ETRQName: atom|updated
  @ClsQName: ManakaiAtomUpdatedElement

  @IFISA: AtomDateConstruct
  @ClsISA: ManakaiAtomDateConstruct

  @f:implements: AtomFeature10
  @mv:refers: DateAG
  @mv:elementContentModel: DateCM

  @enDesc:
    The <XE::atom|updated> element is a Date construct
    indicating the most recent instant in time when an 
    entry or feed was modified in a way the publisher considers
    significant.
##AtomPublishedElement

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        If the node or a descendant of it, which
        is to be modified, is read-only.

## -- Configuration Parameters

boolCParam:
  @QName: cfg|create-child-element
  @tc:nodeStemKey:
    @@@: ccldel
    @@ForCheck: =ManakaiDOM|all
  @c:targetType: tc|Document
  @IsSupportRequired:1
  @TrueCase:
    @@c:isSupported:1
    @@enDesc:
      If the parameter is set to <DOM::true>, some DOM attributes
      that returns an element will create a child element
      when there is no element that met the condition defined
      for that DOM attribute.
  @FalseCase:
    @@c:isSupported:1
    @@IsSupportRequired:1
    @@IsDefault:1
    @@enDesc:
      If the parameter is set to <DOM::true>, some DOM attributes
      that returns an element will <EM::not> create a child element
      even when there is no element that met the condition defined
      for that DOM attribute.
  @TestC:
    @@QName: cfg.create-child-element.set.test
    @@PerlCDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;
      my $cp = <Q::cfg|create-child-element>;

      $test->id ('default');
      $test->assert_false ($cfg-><M::CFG.getParameter> ($cp));

      $test->id ('set.f.to.t');
      $cfg-><M::CFG.setParameter> ($cp => true);
      $test->assert_true ($cfg-><M::CFG.getParameter> ($cp));

      $test->id ('set.t.to.f');
      $cfg-><M::CFG.setParameter> ($cp => false);
      $test->assert_false ($cfg-><M::CFG.getParameter> ($cp));

      $cfg-><M::CFG.setParameter> ($cp => true);

      $test->id ('reset');
      $cfg-><M::CFG.setParameter> ($cp => null);
      $test->assert_false ($cfg-><M::CFG.getParameter> ($cp));

ResourceDef:
  @QName: CFG
  @AliasFor: c|DOMConfiguration

ElementTypeBinding:
  @Name: boolCParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: c|DOMConfigurationParameter
    @@DISCore:resourceType:
      @@@@: DISCore|Property
    @@Type: idl|boolean

ECDef:
  @QName: simpleExtensionElements
  @mv:elementTypeClassName: simple.extra
  @DISCore:resourceType: mv|ElementTypeAdditionalClass

ECDef:
  @QName: structuredExtensionElements
  @mv:elementTypeClassName: structured.extra
  @DISCore:resourceType: mv|ElementTypeAdditionalClass

EMDef:
  @QName: extensionElements
  @mv:elementTypeClassName: extra
  @mv:refers: simpleExtensionElements
  @mv:refers: structuredExtensionElements
  @DISCore:resourceType: mv|ElementTypeAdditionalClass

AGDef:
  @QName: undefinedAttributes
  @mv:attributeTypeGroupName: common.extra

ResourceDef:
  @QName: undefinedContent
  @mv:elementContentModelName: undefined
  @DISCore:resourceType: mv|ElementContentModel
  @cm: dxm|ANY
  @enImplNote:
    (text | anyForeignElement)*

## -- Atom Threading Extension [RFC 4685]

IFClsDef:
  @IFQName: AtomEntryElementThread
  @ClsQName: ManakaiAtomEntryElementThread

  @ClsISA: ManakaiAtomEntryElement

  @f:implements: AtomThreadingFeature10

  @enDesc:
    If the feature <Feature^^DISCore|QName::AtomThreadingFeature10>
    is supported, any <IF::Element> whose element type
    is <XE::atom|entry> <kwd:MUST> implement the <IF::AtomEntryElementThread>
    interface in addition to other appropriate interfaces.

  @Test:
    @@QName: AtomEntryElementThread.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc->create_element_ns (<Q::atom|>, 'entry');

      $test->id ('interface');
      $test->assert_isa ($el, <IFName::AtomEntryElementThread>);

      $test->id ('feature');
      $test->assert_true ($el->is_supported (<Q::fe|AtomThreading> => '1.0'));

  @Attr:
    @@Name: threadInReplyToElements
    @@enDesc:
      A static list of <XE::thr|in-reply-to> child elements of the node.
    @@Type: StaticNodeList
    @@Get:
      @@@enDesc:
        It <kwd:MUST> <I::return a <XE::thr|in-reply-to> child element list>
        of the node.
      @@@PerlDef:
        __CODE{returnChildElementList::
          $node => $self,
          $namespaceURI => {<Q::thr|>},
          $localName => 'in-reply-to',
          $r => $r,
        }__;
##AtomEntryElementThread

IFClsETDef:
  @IFQName: AtomThreadInReplyToElement
  @ETQName: thr|in-reply-to
  @ETRQName: thr|in-reply-to
  @ClsQName: ManakaiAtomThreadInReplyToElement

  @IFISA: AtomDateConstruct
  @ClsISA: ManakaiAtomDateConstruct

  @f:implements: AtomThreadingFeature10
  @mv:refers: atomCommonAttributes

  @cm: undefinedContent

  @enDesc:
    The <XE::thr|in-reply-to> element is used to indicate
    that an entry is a response to another resource.

    If the entry is a response to multiple resources,
    additional <XE::thr|in-reply-to> element <kwd:MAY>
    be used.

    RFC 4685 assigns no significance to the order in which
    multiple <XE::thr|in-reply-to> element appear within
    an entry.

  @Test:
    @@QName: AtomThreadInReplyToElement.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc->create_element_ns (<Q::thr|>, 'in-reply-to');

      $test->id ('interface');
      $test->assert_isa ($el, <IFName::AtomThreadInReplyToElement>);

      $test->id ('feature');
      $test->assert_true ($el->is_supported (<Q::fe|AtomThreading> => '1.0'));

  @ATTR:
    @@Name: ref
    @@enDesc:
      The <XA::ref> attribute of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::ref> attribute> of the node.

      The <XA::ref> attribute specifies the persistent,
      universally unique identifier of the resource being
      responded to.  The value <kwd:MUST> conform to
      the same construction and comparison rules as the
      value of the <XE::atom|id> element.  Though the IRI
      might use a dereferenceable scheme, processors <kwd:MUST-NOT>
      assume that it can be dereferenced.

      The <XE::thr|in-reply-to> element <kwd:MUST> contain
      a <XA::ref> attribute identifying the resource that
      is being respnoded to.

      If the resource being responded to does not have a persistent,
      universally unique identifier, the publisher <kwd:MUST> assign an
      identifier that satisfies all the considerations in Section 4.2.6 of
      RFC 4287 for use as the value of the <XA::ref> attribute.
      In that case, if a representation of the resource can be retrieved
      from an IRI that can be used as a valid atom:id value, then this IRI
      <kwd:SHOULD> be used as the value of both the <XA::ref> and
      <XA::href> attributes.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'ref',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'ref',
          $given => $given,
        }__;
	
  @ATTR:
    @@Name: source
    @@enDesc:
      The <XA::source> attribute of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::source> attribute> of the node.

      The <XA::source> attribute <kwd:MAY> be used to specify the IRI
      of an Atom Feed or Entry Document containing an 
      <XE::atom|entry> with an <XE::atom|id> value equal to the
      value of the <XA::ref> attribute.  The IRI specified <kwd:MUST>
      be dereferenceable.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'source',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'source',
          $given => $given,
        }__;
	
  @ATTR:
    @@Name: href
    @@enDesc:
      The <XA::href> attribute of the element.

      It <kwd:MUST> <I::reflect the URI value
      of the <XA::href> attribute> of the node.

      The <XA::href> attribute specifies an IRI that may be used
      to retrieve a representation of the resource being
      responded to.  The IRI specified <kwd:MUST> be
      dereferenceable.
    @@Type: DOMString
    @@actualType: DOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'href',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrURIValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'href',
          $given => $given,
        }__;
  
  @ATTR:
    @@Name: type
    @@enDesc:
      The <XA::type> attribute of the element.

      It <kwd:MUST> <I::reflect the string value
      of the <XA::type> attribute> of the node.

      The <XA::type> attribute <kwd:MAY> be used to provide
      a hint to the client about the media type of the
      resource identified by the <XA::href> attribute.
      The <XA::type> attribute is only meaningful if a
      corresponding <XA::href> attribute is also provided.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the algorithm returns <DOM::null>.
      @@@PerlDef:
        __CODE{getReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Removes the attribute.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrStringValue::
          $node => $self,
          $namespaceURI => {null},
          $localName => 'type',
          $given => $given,
        }__;
##AtomThreadInReplyToElement

IFClsDef:
  @IFQName: AtomLinkElementThread
  @ClsQName: ManakaiAtomLinkElementThread

  @ClsISA: ManakaiAtomLinkElement

  @f:implements: AtomThreadingFeature10

  @enDesc:
    An <XE::atom|link> element with a <XA::rel> attribute value of
    <XML::replies> may be used to reference a resource where responses
    to an entry may be found.  If the <XA::type> attribute of the 
    <XE::atom|link> is omitted, its value is assumed to be 
    <XML::application/atom+xml>.

    A <XML::replies> link appearing as a child of the <XE::atom|feed>
    or <XE::atom|source> element indicates that the referenced
    resource likely contains responses to any of that 
    feed's entries.  A <XML::replies> 
    link appearing as a child of an <XE::atom|entry> element
    indicates that the linked resource likely contains responses
    specific to that entry.

    If the feature <Feature^^DISCore|QName::AtomThreadingFeature10>
    is supported, any <IF::Element> whose element type
    is <XE::atom|link> <kwd:MUST> implement the <IF::AtomLinkElementThread>
    interface in addition to other appropriate interfaces.

  @Test:
    @@QName: AtomLinkElementThread.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc->create_element_ns (<Q::atom|>, 'link');

      $test->id ('interface');
      $test->assert_isa ($el, <IFName::AtomLinkElementThread>);

      $test->id ('feature');
      $test->assert_true ($el->is_supported (<Q::fe|AtomThreading> => '1.0'));

  @ATTR:
    @@Name: threadCount
    @@enDesc:
      The <XA::thr|count> attribute of the element.

      It <kwd:MUST> <I::reflect the non-negative integer value
      of the <XA::thr|count> attribute> of the node.

      An <XE::atom|link> element using the <XML::replies>
      <XA::rel> attribute value <kwd:MAY> contain 
      a <XA::thr|count> attribute whose value is a
      non-negative integer that provides a hint to clients
      as to the total number of replies contained by the
      linked resource.  The value is advisory and
      may not accurately reflect the actual number of replies.
    @@Type: idl|long
    @@Get:
      @@@PerlDef:
        __CODE{getReflectAttrNonNegativeIntegerValue::
          $node => $self,
          $namespaceURI => {<Q::thr|>},
          $localName => 'count',
          $r => $r,
          $defaultValue => {null},
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{setReflectAttrNonNegativeIntegerValue::
          $node => $self,
          $namespaceURI => {<Q::thr|>},
          $localName => 'count',
          $given => $given,
        }__;

    @@Test:
      @@@QName: AtomLinkElementThread.threadCount.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $link = $doc->create_element_ns (<Q::atom|>, 'link');

        $test->id ('default');
        $test->assert_num_equals
                 (expected_value => -1,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);

        $test->id ('zero');
        $link-><AS::AtomLinkElementThread.threadCount> (0);
        $test->assert_num_equals
                 (expected_value => 0,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);
        $test->id ('zero.attr');
        $test->assert_equals ($link->get_attribute_ns (<Q::thr|>, 'count'), '0');

        $test->id ('one');
        $link-><AS::AtomLinkElementThread.threadCount> (1);
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);
        $test->id ('one.attr');
        $test->assert_equals ($link->get_attribute_ns (<Q::thr|>, 'count'), '1');

        $test->id ('10000');
        $link-><AS::AtomLinkElementThread.threadCount> (10000);
        $test->assert_num_equals
                 (expected_value => 10000,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);
        $test->id ('10000.attr');
        $test->assert_equals ($link->get_attribute_ns (<Q::thr|>, 'count'),
                              '10000');

        $test->id ('+10000');
        $link->set_attribute_ns (<Q::thr|>, 'thr:count', '+10000');
        $test->assert_num_equals
                 (expected_value => 10000,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);

        $test->id ('010000');
        $link->set_attribute_ns (<Q::thr|>, 'thr:count', '010000');
        $test->assert_num_equals
                 (expected_value => 10000,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);

        $test->id ('-100');
        $link-><AS::AtomLinkElementThread.threadCount> (-100);
        $test->assert_num_equals
                 (expected_value => -1,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);
        $test->id ('-100.attr');
        $test->assert_false ($link->has_attribute_ns (<Q::thr|>, 'count'));

        $test->id ('120a');
        $link->set_attribute_ns (<Q::thr|>, 'thr:count', '120a');
        $test->assert_num_equals
                 (expected_value => -1,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);

        $test->id ('-1');
        $link-><AS::AtomLinkElementThread.threadCount> (-1);
        $test->assert_num_equals
                 (expected_value => -1,
                  actual_value =>
                    $link-><AG::AtomLinkElementThread.threadCount>);
        $test->id ('-1.attr');
        $test->assert_false ($link->has_attribute_ns (<Q::thr|>, 'count'));

  @enImplNote:
    @@ddid: updated
    @@@:
      {TODO::
        <XA::thr|updated> attribute
      }
##AtomLinkElementThread

enImplNote:
  @@ddid: total
  @@@:
    {TODO::
      <XE::thr|total>
    }

enImplNote:
  @@ddid: threaddtd
  @@@:
    {TODO::
      DTD impl for threading
    }
</xmp>

<section>
<h2 id=changes-from-earlier-versions><span class=secno>5 </span>Changes from earlier versions</h2>

<p>Earlier versions of this specification defined following feature
strings:

</p><ul>

<li>Feature
<dfn id=http://suika.fam.cx/www/2006/feature/atom><code>http://suika.fam.cx/www/2006/feature/Atom</code></dfn>
version <code>1.0</code>, identifying the core part of the Atom DOM.

</li><li>Feature
<dfn id=http://suika.fam.cx/www/2006/feature/atomthreading><code>http://suika.fam.cx/www/2006/feature/AtomThreading</code></dfn>
version <code>1.0</code>, identifying the Atom Threading Extension
support of the Atom DOM.

</li></ul>

<p>Earlier versions of this specification defined the <a href=#AtomImplementation><code>AtomImplementation</code></a>
interface, which is now defined as a partial interface for
<a href=#domimplementation><code>DOMImplementation</code></a>.

</p><p>Earlier versions of this specification defined the empty
<dfn id=atomdocument><code>AtomDocument</code></dfn> interface.

</p><p>Earlier versions of this specification specified different handling
of <code>null</code> values for reflecting attributes.  They are
removed for consistency with DOM and HTML.

</p><p>Earlier versions of this specification specfied list of elements
returned by various attributes as <a href=#concept-collection-static title=concept-collection-static>static</a>, which is now changed to
<a href=#concept-collection-live title=concept-collection-live>live</a> for consistency with
HTML DOM.

</p></section>

<section class="reference normative">
<h2 class=no-num id=references>References</h2>

<dl>

<dt id=ref-ATOM>ATOM
</dt><dd><a href=http://tools.ietf.org/html/rfc4287><cite>The Atom Syndication Format</cite></a>, IETF, RFC 4287.

</dd><dt id=ref-DOM>DOM
</dt><dd><a href=http://dom.spec.whatwg.org/><cite>DOM Standard</cite></a>, WHATWG.

</dd><dt id=ref-HTML>HTML
</dt><dd><a href=http://www.whatwg.org/specs/web-apps/current-work/complete.html><cite>HTML Standard</cite></a>, WHATWG.

</dd><dt id=ref-MANAKAI>MANAKAI
</dt><dd><a href=http://suika.suikawiki.org/~wakaba/wiki/sw/n/manakai%20DOM%20Extensions><cite>manakai DOM Extensions</cite></a>, manakai project.

</dd><dt id=ref-RFC2119>RFC2119
</dt><dd><a href=http://tools.ietf.org/html/rfc2119><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>, IETF, RFC 2119, BCP 14.

</dd><dt id=ref-SVG>SVG
</dt><dd><a href=https://svgwg.org/svg2-draft/single-page.html><cite>Scalable Vector Graphics (SVG) 2</cite></a>, W3C SVG WG.

</dd><dt id=ref-WEBIDL>WEBIDL
</dt><dd><a href=http://dev.w3.org/2006/webapi/WebIDL/><cite>WebIDL</cite></a>, Cameron McCormack.

</dd></dl>

</section>
</body></html>